- 数组

  - 题1：两数之和（两个值，根据其中一个值满足条件来找另一个值，可用哈希）

    ```c++
    题目：
    	输入：nums=[2, 7, 11, 15], target=9，
    	条件：nums[0]+nums[1]=2+7=9
    	输出：[0, 1]
    分析：
      1. 查找问题
      2. 数组有两个值：position, value
      3. 根据value值判断某个条件，返回value所在的position
    思路：
      1. 暴力：两次循环
      2. 哈希：一次循环，循环内哈希
      	1. 全部搬进哈希表再找
      	2. 边找边加）
      3. 双指针？
    ```

  - 题15：三数之和

    ```c++
    题目：
      输入：nums = [-1, 0, 1, 2, -1, -4]，
    	条件：a + b + c = 0 ？找出所有满足条件且不重复的三元组
    	输出：[[-1, 0, 1],[-1, -1, 2]]
    分析：
      1. 跟“题1.两数之和”不太一样，该题不需要position值，单纯依赖于value
      2. 怎么去重？去重有哪些方法（总结一下）？：有序可以方便去重（这里双指针可以方便去重）
      3. 双指针：复杂度O(n)，双指针要求序列容器「有序」
    思路：
      1. 暴力：3个for，复杂度O(n^3)
      2. 双指针：排序(O(n*logn)) + for(O(n))*双指针(O(n)) = O(n^2) 
      	//双指针for循环里第一个指针从for循环的第一个开始，前面跳过的剪掉，不会导致出现[-1,-2,3]和[-2,3,1]这种重复
    ```

  - 题11.盛最多的水（典型双指针，思想是每次排除掉不可能增加的）

    ```c++
    【小结】【双指针】
      1. 双指针需要在某时刻，根据什么条件判断要移动哪个指针，比如当两数和>target，right--；
      2. 如果需要对两个数之间的关系做判断或操作，可以考虑双指针
    ```

  - 题4.寻找两个有序数组的中位数【困难】

  - 题16.最接近的三数之和

    ```c++
    跟“题15.三数之和”基本一样：for循环锁第一个值 + 双指针
    //要点：指针移动的根据是去掉不可能的，双指针本质是一种遍历，并不是说最后找到的是最好的，而是最好的一定在我遍历的过程中
    ```

  - 题18.四数之和：for+for+双指针

  - 题26.删除排序数组中的重复项

    ```c++
    思路：双指针中的“快慢指针”
    做法：i=0,j=1;for(j++){j和i不一样的话，i++，复制j给i，j++}
    ```

  - 题27.移除元素：双指针，后面的不是value的和前面是value的swap，直到指针相遇

  - 题31.下一个排序：双指针，从后找前面比它大的第一个数，插入到那数前面。如果是降序，则反向排列

  - 题33.搜索旋转排序数组：二分查找，注意排除时两种情况，即mid的2种位置，去掉哪一边

    ```c++
    【小结】【二分查找】
      1. 如果是非递归版本，而且是减治二分查找，起手while(left<right)最终left=right
      2. while里：想好mid怎么赋值，之后是if和else，想好条件是什么(目的是为了剪枝而不是选择)，边界怎么改
    ```

  - 题41.缺失的第一个正数【困难】：要求O(n)所以考虑哈希查找。

    ```c++
    做法：最多就是n+1(n指数的个数)，从1～n遍历，每次哈希看看有没有这个数，有就ans+=1，没有就是这个数了
    ```

  - 题42.接雨水【困难】：还是可以通过双指针，但这题难点在于怎么看本质，可以有按列和按行两种思路

    ```c++
    按行：可以直接用左右双指针往里统计，找到第一个left和第一个right，中间空的就都有水
    按列：双指针，找>=left的right，然后统计中间的水
    ```

  - 题53.最大子序和【有趣】：动态规划思想来看清button-up过程

    ```c++
    【小结】【动态规划】
     什么问题可以用动态规划？
     1. 某一个阶段的结果只由前一步决定（可能前一步有多种状态）
     2. 该阶段能够知道哪一个是最优解
      
     重点：写出递推公式（比如纸币问题中）
     f(n) = min(f(n-1),f(n-5),f(n-11))+1
    ```

  - 题55.合并区间：双指针，但是指向的是整个数组，分3中情况：包含、不相交、相交
  
  - 题78.子集：动态规划（双100）
  
    ```c++
    数量上：f(n) = f(n-1) * 2(但题目不是求数量)
    数组元素：f(n) = {f(n-1) (多个vector),每个vector加入新元素}
    ```
  
  - 题105.从前序和中序遍历序列构建二叉树
  
  - 题118.杨辉三角形：动态规划（双100）
  
    ```c++
    动态规划思想
      1. 一行一行加进ans
      2. 一行是row，row是一个vector<int>
      	1. 先加入1；
      	2. 中间i>=2时，则利用上一层依次算出；for循环中：row.push_back(ans[i-1][j-1]+ans[i-1][j])
      	3. 最后i>=1时，加入1作为结尾
    ```
  
  - 题121.买卖股票最佳时机-一次买入卖出：
  
    ```c++
    动态规划思想
      1. 递推式：第i天的最低买入价 = min(前i-1的最低买入价,当前价)
      2. 第i天最大盈利 = 当天价格 - 前(i-1)天最低价
      3. 维护一个low[]和max_earning
    ```
  
  - 题122.买卖股票最佳时机-多次买入卖出：简单遍历即可，比前一个大就把earning+=差值
  
    